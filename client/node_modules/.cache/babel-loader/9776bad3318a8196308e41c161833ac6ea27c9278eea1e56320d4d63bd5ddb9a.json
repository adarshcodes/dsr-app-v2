{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.interpolateAs = interpolateAs;\nvar _routeMatcher = require(\"./route-matcher\");\nvar _routeRegex = require(\"./route-regex\");\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches =\n  // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') ||\n  // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param];\n    // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n    let replaced = `[${repeat ? '...' : ''}${param}]`;\n    if (optional) {\n      replaced = `${!value ? '/' : ''}[${replaced}]`;\n    }\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && (\n    // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(\n    // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}","map":{"version":3,"names":["interpolateAs","_routeMatcher","require","_routeRegex","route","asPathname","query","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","params","Object","keys","every","param","value","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result"],"sources":["../../../../../src/shared/lib/router/utils/interpolate-as.ts"],"sourcesContent":[null],"mappings":"AAAA;;;;;QAKgBA,aAAa,GAAbA,aAAa;AAHG,IAAAC,aAAiB,GAAAC,OAAA,CAAjB,iBAAiB;AACnB,IAAAC,WAAe,GAAAD,OAAA,CAAf,eAAe;AAEtC,SAASF,aAAaA,CAC3BI,KAAa,EACbC,UAAkB,EAClBC,KAAqB,EACrB;EACA,IAAIC,iBAAiB,GAAG,EAAE;EAE1B,MAAMC,YAAY,GAAG,IAAAL,WAAa,EAAOM,aAAP,CAACL,KAAK,CAAC;EACzC,MAAMM,aAAa,GAAGF,YAAY,CAACG,MAAM;EACzC,MAAMC,cAAc;EAClB;EACA,CAACP,UAAU,KAAKD,KAAK,GAAG,IAAAH,aAAe,EAAcY,eAAd,CAACL,YAAY,CAAC,CAACH,UAAU,CAAC,GAAG,EAAE;EACtE;EACA;EACAC,KAAK;EAEPC,iBAAiB,GAAGH,KAAK;EACzB,MAAMU,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACN,aAAa,CAAC;EAEzC,IACE,CAACI,MAAM,CAACG,KAAK,CAAEC,KAAK,IAAK;IACvB,IAAIC,KAAK,GAAGP,cAAc,CAACM,KAAK,CAAC,IAAI,EAAE;IACvC,MAAM;MAAEE,MAAM;MAAEC;IAAQ,CAAE,GAAGX,aAAa,CAACQ,KAAK,CAAC;IAEjD;IACA;IACA,IAAII,QAAQ,GAAI,IAAGF,MAAM,GAAG,KAAK,GAAG,EAAG,GAAEF,KAAM,GAAE;IACjD,IAAIG,QAAQ,EAAE;MACZC,QAAQ,GAAI,GAAE,CAACH,KAAK,GAAG,GAAG,GAAG,EAAG,IAAGG,QAAS,GAAE;;IAEhD,IAAIF,MAAM,IAAI,CAACG,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,EAAEA,KAAK,GAAG,CAACA,KAAK,CAAC;IAEpD,OACE,CAACE,QAAQ,IAAIH,KAAK,IAAIN,cAAc;IACpC;IACCL,iBAAiB,GAChBA,iBAAiB,CAAEkB,OAAO,CACxBH,QAAQ,EACRF,MAAM,GACFD,KAAM,CACHO,GAAG;IACF;IACA;IACA;IACA;IACCC,OAAO,IAAKC,kBAAkB,CAACD,OAAO,CAAC,CACzC,CACAE,IAAI,CAAC,GAAG,CAAC,GACZD,kBAAkB,CAACT,KAAK,CAAW,CACxC,IAAI,GAAG,CAAC;GAEd,CAAC,EACF;IACAZ,iBAAiB,GAAG,EAAE,CAAC;IAAA;IAEvB;IACA;;;EAEF,OAAO;IACLO,MAAM;IACNgB,MAAM,EAAEvB;GACT"},"metadata":{},"sourceType":"script","externalDependencies":[]}